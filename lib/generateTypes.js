/* global globalThis */
/**
 * Converts a database object parameter type to a typescript type
 *
 * @param {string} type Data object parameter type
 * @param {boolean | undefined} isProc Whether the target is a data object field or a procedure parameter (true for procedure parameter)
 * @returns {string} Typescript type matching the data object parameter type
 */
function afTypeToTsType(type, isProc = false) {
  if (type === "uniqueidentifier") {
    return "string";
  } else if (["date", "datetime"].includes(type)) {
    return isProc ? "string | Date" : "Date";
  }

  return type;
}

/**
 * Generates Typescript definitions for data objects generated by Appframe
 *
 * @param {Record<string, Record<string, string>>} parameterOverrides Overrides for data object field types
 */
function getDataObjectTypes(parameterOverrides = {}) {
  let result = [];
  let globals = [];
  let dataObjects = Object.values(globalThis.af.article.dataObjects ?? {}).sort(
    (p1, p2) => (p1.getDataSourceId() >= p2.getDataSourceId() ? 1 : -1)
  );

  for (let dataObject of dataObjects) {
    let id = dataObject.getDataSourceId();
    let typeName = id.startsWith("ds") ? id.substring(2) : id;
    typeName = typeName + "Record";
    result.push(`export type ${typeName} = {`);

    for (let field of dataObject.getFields()) {
      let type =
        parameterOverrides[id]?.[field.name] ??
        afTypeToTsType(field.type ?? "string") +
          (field.nullable ? " | null" : "");
      let fieldName =
        field.name.indexOf("-") > 0 ? `"${field.name}"` : field.name;

      result.push(`\t${fieldName}: ${type};`);
    }

    result.push("};");
    result.push("");

    globals.push(`${id}: DataObject<${typeName}>;`);
  }

  if (globals.length === 0) {
    return "";
  }

  result.push("declare global {");
  result.push(globals.map((g) => "\tvar " + g).join("\n"));
  result.push("\tinterface Window {");
  result.push(globals.map((g) => "\t\t" + g).join("\n"));
  result.push("\t}");
  result.push("}");

  return result.join("\n");
}

/**
 * Generates Typescript definitions for stored procedures generated by Appframe
 *
 * @param {Record<string, Record<string, string> | Record<"__required", string[]>>} parameterOverrides
 * @param {Record<string, string>} returnTypes
 */
function getProcedureTypes(parameterOverrides = {}, returnTypes = {}) {
  let result = [];
  let globals = [];
  let procedures = Object.values(globalThis.af.article.procedures ?? {}).sort(
    (p1, p2) => (p1.options.procedureId >= p2.options.procedureId ? 1 : -1)
  );

  for (let procedure of procedures) {
    let id = procedure.options.procedureId;
    let typeName = id.startsWith("proc") ? id.substring(4) : id;
    typeName = typeName + "Params";

    result.push(`export type ${typeName} = {`);

    for (let param of procedure.getParameters()) {
      let type =
        parameterOverrides[id]?.[param.name] ??
        afTypeToTsType(param.type, true) + " | null";
      let required = parameterOverrides[id]?.__required?.includes(param.name);

      result.push(
        `\t${param.name}${required || param.required ? "" : "?"}: ${type};`
      );
    }

    result.push("};");
    result.push("");

    globals.push(
      `${id}: Procedure<${typeName}, ${
        Object.keys(returnTypes).includes(id) ? returnTypes[id] : "any"
      }>;`
    );
  }

  if (globals.length === 0) {
    return "";
  }

  result.push("declare global {");
  result.push(globals.map((g) => "\tvar " + g).join("\n"));
  result.push("\tinterface Window {");
  result.push(globals.map((g) => "\t\t" + g).join("\n"));
  result.push("\t}");
  result.push("}");

  return result.join("\n");
}

export function generateTypes(customExists = false, overridesConfig = {}) {
  let result = [
    `import { DataObject, Procedure } from "@olenbetong/data-object";${
      customExists ? '\nimport * as Custom from "./customTypes";' : ""
    }`,
  ];

  result.push(getDataObjectTypes(overridesConfig["parameterTypes"]));
  result.push(
    getProcedureTypes(
      overridesConfig["parameterTypes"],
      overridesConfig["procedureReturnTypes"]
    )
  );

  return result.join("\n\n");
}
